<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Hieu Doan</title><link rel="icon" type="image/x-icon" href="/favicon.ico"/><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#171717"/><meta name="apple-mobile-web-app-title" content="Hieu Doan"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-touch-fullscreen" content="yes"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/4e1c4e2ceb5de610.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4e1c4e2ceb5de610.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-c5d3e1342d2407ee.js" defer=""></script><script src="/_next/static/chunks/framework-dd1a45b985e48fb7.js" defer=""></script><script src="/_next/static/chunks/main-599b4910eb16b1ca.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e197af946ceb1d50.js" defer=""></script><script src="/_next/static/chunks/ff3b2f09-5e24d755f3900c82.js" defer=""></script><script src="/_next/static/chunks/5179-3d4a8772b66ba249.js" defer=""></script><script src="/_next/static/chunks/8853-e15c07d9bdef6d7d.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...id%5D-63f736b88953fea9.js" defer=""></script><script src="/_next/static/kmI-DEJGyjj_qX9Ur3MzG/_buildManifest.js" defer=""></script><script src="/_next/static/kmI-DEJGyjj_qX9Ur3MzG/_ssgManifest.js" defer=""></script></head><body class="bg-neutral-900 text-neutral-100 antialiased"><div id="__next"><div class="__className_5cfdac __className_9a8899 bg-neutral-900 text-neutral-100"><div class="container mx-auto min-h-screen p-8"><article class="markdown-body border-b border-neutral-800 bg-neutral-900!"><button type="button" class="inline-flex items-center justify-center rounded-full px-6 py-2 font-semibold 
  border border-white/20
  bg-white/10
  backdrop-blur-lg
  shadow-lg shadow-black/30
  text-white placeholder:text-neutral-400
  transition duration-300
  focus:outline-none focus:ring-2 focus:ring-white/30
 cursor-pointer w-full">Download PDF</button><h1 class="text-xl font-black">Principal Engineer</h1><span class="inline-block rounded-full border border-white/20 bg-white/10 px-3 py-1 text-sm font-medium shadow shadow-black/20 backdrop-blur-lg ">2025-07-30</span><div><h2>📚 Table of Contents</h2>
<ul>
<li><a href="#-table-of-contents">📚 Table of Contents</a></li>
<li><a href="#-back-end">🔧 Back-end</a>
<ul>
<li><a href="#-microservices-architecture">🧱 Microservices Architecture</a></li>
<li><a href="#%EF%B8%8F-apache-kafka">⚙️ Apache Kafka</a></li>
<li><a href="#%EF%B8%8F-java--spring-boot">☕️ Java + Spring Boot</a></li>
<li><a href="#-postgresql">🛢 PostgreSQL</a></li>
</ul>
</li>
<li><a href="#-front-end">🖼 Front-end</a>
<ul>
<li><a href="#nodejs">Node.js</a></li>
<li><a href="#%EF%B8%8F-react">⚛️ React</a></li>
<li><a href="#-graphql">🔗 GraphQL</a></li>
</ul>
</li>
<li><a href="#%EF%B8%8F-3-devops-and-infrastructure">☁️ 3. DevOps and Infrastructure</a>
<ul>
<li><a href="#-harness-cicd">🔄 Harness CI/CD</a></li>
<li><a href="#%EF%B8%8F-aws">☁️ AWS</a></li>
<li><a href="#solution-design">Solution Design</a></li>
</ul>
</li>
<li><a href="#faqs">FAQs</a>
<ul>
<li><a href="#sql-vs-nosql">SQL vs NoSQL</a></li>
<li><a href="#monolith-vs-microservices">Monolith vs Microservices</a></li>
<li><a href="#vertical-vs-horizontal">Vertical vs Horizontal</a></li>
</ul>
</li>
</ul>
<h2>🔧 Back-end</h2>
<h3>🧱 Microservices Architecture</h3>
<ul>
<li>Core Principles
<ul>
<li>Single Responsibility: Each service owns a bounded context (DDD).</li>
<li>Loose Coupling &#x26; High Cohesion: Minimize dependencies, maximize internal focus.</li>
<li>Autonomy: Services deploy, scale, and evolve independently.</li>
<li>Decentralized Data Management: Each service manages its own database; avoid shared DB.</li>
<li>Resiliency &#x26; Observability: Circuit breakers, retries, metrics, tracing, logging.</li>
</ul>
</li>
<li>Benefits
<ul>
<li>Independent deployments (CI/CD friendly).</li>
<li>Polyglot architecture (choose best tech per service).</li>
<li>Fault isolation (failure in one service doesn’t cascade).</li>
<li>Scalability per component (e.g., scale only order service).</li>
</ul>
</li>
<li>Challenges
<ul>
<li>Data consistency (distributed transactions).</li>
<li>Operational complexity (monitoring, debugging).</li>
<li>Network latency &#x26; reliability (timeouts, retries).</li>
<li>Deployment orchestration (service discovery, configuration management).</li>
</ul>
</li>
<li>Design Patterns
<ul>
<li>Database per service</li>
<li>CQRS (Command Query Responsibility Segregation)</li>
<li>Event sourcing (capture state changes as immutable events)</li>
<li>Strangler Fig Pattern (incremental migration from monolith)</li>
</ul>
</li>
<li>Common questions
<ul>
<li>What are the main challenges of microservices architecture? Hard to maintain consistency without 2PC. Use Saga/Event patterns.
<ul>
<li>2PC (All for Nothing)</li>
<li>Saga Pattern
<ul>
<li>Break transaction into local transactions per service.</li>
<li>Each service publishes an event after completing its local action.</li>
<li>Other services react to events (Choreography) or are told what to do (Orchestration).</li>
<li>Use compensating actions to roll back (e.g., cancel payment if inventory fails).</li>
</ul>
</li>
</ul>
</li>
<li>Operational complexity: Monitoring, logging, tracing across services? Use correlationId and Generate at API Gateway or entry service.</li>
<li>Versioning &#x26; backward compatibility: Handle evolving contracts with API versioning and schema evolution.</li>
<li>Benefits of Orchestration
<ul>
<li>Centralized Workflow Control (BPMN diagrams)</li>
<li>Simpler to reason about success/failure paths compared to multiple scattered events.</li>
<li>Can trigger compensating actions immediately when a step fails.</li>
<li>Avoids “event storming” where multiple services react redundantly.</li>
<li>Flexible Sequencing: Can reorder or skip steps without touching multiple services.</li>
<li>Good for complex workflows (e.g., multi-step approvals, conditional branching).</li>
<li>When to Prefer Orchestration
<ul>
<li>Complex workflows with many steps or compensations.</li>
<li>Dynamic flows (branching, conditional logic).</li>
<li>When you need auditability and monitoring of workflows.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Inbox / Outbox
<ul>
<li>Outbox
<ul>
<li>In microservices, dual writes happen often:
<ul>
<li>Write to local DB (business state).</li>
<li>Publish event to message broker (Kafka/RabbitMQ).</li>
</ul>
</li>
<li>Ensure that when you update a database and publish an event, both happen atomically.
<ul>
<li>How It Works
<ul>
<li>When processing a command, write both:
<ul>
<li>Business data (e.g., order table)</li>
<li>Event data (e.g., outbox table) into the same database transaction.</li>
</ul>
</li>
<li>A separate process (or Kafka Connect/Debezium) reads outbox table and publishes the event to Kafka.</li>
<li>After successful publish, mark outbox entry as processed (or delete).</li>
</ul>
</li>
</ul>
</li>
<li>Benefits
<ul>
<li>Guarantees no lost events (DB and event always in sync).</li>
<li>Avoids dual write problem without 2PC.</li>
<li>Works well with Kafka + relational DB.</li>
</ul>
</li>
<li>Trade-offs
<ul>
<li>Extra outbox table management (cleanup, indexes).</li>
<li>Slight latency between DB commit and event publish.</li>
<li>Need idempotent consumers (events may be delivered at least once).</li>
</ul>
</li>
</ul>
</li>
<li>Inbox
<ul>
<li>Goal
<ul>
<li>Ensure idempotent event consumption (avoid double-processing events).</li>
</ul>
</li>
<li>How It Works
<ul>
<li>Consumer stores event ID in inbox table when processing event.</li>
<li>Before processing, check if event ID exists:
<ul>
<li>If exists → ignore (duplicate).</li>
<li>If not → process and insert into inbox.</li>
</ul>
</li>
</ul>
</li>
<li>Benefits
<ul>
<li>Ensures exactly-once processing in consumer.</li>
<li>Protects against replayed or duplicate messages.</li>
</ul>
</li>
<li>Trade-offs
<ul>
<li>Requires storage for inbox table.</li>
<li>More DB writes on consumers.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Kafka
<ul>
<li>Topic
<ul>
<li>A log-structured data stream.</li>
<li>Append-only; events are immutable.</li>
<li>Divided into partitions → allows horizontal scaling and parallel consumption.</li>
<li>Each message has an offset (position in partition).</li>
</ul>
</li>
<li>Consumer Groups
<ul>
<li>Group of consumers sharing the same group ID.</li>
<li>Kafka assigns partitions to consumers → ensures load balancing.</li>
<li>Within a group:
<ul>
<li>Each partition consumed by only one consumer (scales horizontally).</li>
</ul>
</li>
<li>Multiple groups can consume the same topic independently (e.g., analytics vs billing).</li>
</ul>
</li>
<li>Examples
<ul>
<li><code>order.events</code> contains all order-related events: <code>OrderCreated</code>, <code>OrderPaid</code>, <code>OrderShipped</code>.</li>
<li>events are distributed by partition key (e.g., orderId):</li>
</ul>
</li>
<li>Retention
<ul>
<li>Kafka stores events for a configurable period (e.g., 7 days).</li>
<li>Consumers can replay events by resetting offsets (great for recovery/debugging).</li>
</ul>
</li>
<li>Delivery Semantics
<ul>
<li>At-least-once (default).
<ul>
<li>Each message is delivered one or more times.</li>
<li>Duplicates may occur, but no message is lost.</li>
<li>Consumer processes message first, then commits offset (auto or manual).</li>
<li>If crash happens after processing but before commit, message is re-delivered.</li>
</ul>
</li>
<li>At-most-once (manual offset commit control).
<ul>
<li>Each message is delivered zero or one time.</li>
<li>No duplicates, but possible data loss.</li>
<li>Commit offset before processing message.</li>
<li>If crash occurs after commit but before processing, message is lost.</li>
</ul>
</li>
<li>Exactly-once (requires idempotent producers + transactional APIs).
<ul>
<li>Each message is delivered once and only once (no duplicates, no loss).</li>
<li>Idempotent Producer (enable.idempotence=true) -> ensures no duplicates during retries.</li>
<li>Transactional API -> ensures atomic writes + offset commits.</li>
</ul>
</li>
</ul>
</li>
<li>Why Kafka is Popular in Microservices
<ul>
<li>Offset
<ul>
<li>Offset = sequential ID for each record within a partition.</li>
<li>Starts at 0, increments by 1 per message.</li>
<li>Identifies a unique position in a partition.</li>
</ul>
</li>
<li>High throughput + horizontal scalability (millions of messages/sec).</li>
<li>Replayability: Consumers can reprocess past events (e.g., rebuild state).</li>
<li>Decoupled architecture: Multiple consumers read same event independently.</li>
<li>Event sourcing &#x26; CQRS: Naturally supports state rebuild and projections.
<ul>
<li>Store different states (Instead of storing order: {status: SHIPPED}, store: OrderCreated, OrderPaid, OrderShipped)</li>
</ul>
</li>
<li>Strong ordering within partitions: Good for workflows per entity (e.g., per order ID).</li>
<li>Schema Registry
<ul>
<li>Definition
<ul>
<li>Service that manages schemas (Avro, JSON Schema, Protobuf) for Kafka topics.</li>
<li>Producers and consumers register and validate schemas to ensure compatibility.</li>
</ul>
</li>
<li>How It Works
<ul>
<li>Each schema gets an ID stored in Kafka message header.</li>
<li>Consumer fetches schema by ID → deserializes message correctly.</li>
<li>Supports schema evolution (backward/forward/full compatibility).</li>
</ul>
</li>
<li>Key points
<ul>
<li>Always add default values for new fields (avoid breaking old consumers).</li>
<li>Avoid removing fields — mark them as deprecated instead.</li>
<li>Choose compatibility mode based on rollout strategy (backward is safest).</li>
<li>Use Schema Registry’s versioning to manage multiple schema versions in parallel.</li>
<li>When using Kafka Connect or CDC, schemas evolve automatically with registry checks.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>⚙️ Apache Kafka</h3>
<ul>
<li>Concepts:
<ul>
<li>Topics, partitions, consumer groups, offset management</li>
<li>At-least-once vs. exactly-once semantics</li>
</ul>
</li>
<li>Use Cases: Event sourcing, change data capture (CDC), stream processing</li>
<li>Tools: Kafka Streams, Kafka Connect, schema registry (e.g., Avro with Confluent)</li>
</ul>
<h3>☕️ Java + Spring Boot</h3>
<ul>
<li>
<p>Core knowledge:</p>
<ul>
<li>Spring Boot Autoconfiguration, Profiles, Actuators</li>
<li>Dependency injection with Spring Framework</li>
<li>Exception handling, validation, and AOP</li>
</ul>
</li>
<li>
<p>Advanced topics:</p>
<ul>
<li>Spring Cloud: Config, Discovery, Gateway</li>
<li>Reactive programming (WebFlux) – especially with Kafka or streaming</li>
<li>Observability with Spring Boot: Micrometer, Prometheus, Zipkin</li>
</ul>
</li>
<li>
<p>Difference between abstract class and interface?</p>
<ul>
<li>Purpose: Base class for related objects; partial implementation vs Contract/behavior without implementation</li>
<li>Inheritance: A class can extend one abstract class vs A class can implement multiple interfaces</li>
<li>Constructor: Can define constructors (called by subclasses) vs No constructors (no state to initialize)</li>
<li>Access Modifiers: Can use any (private, protected, etc.) vs All methods are implicitly public abstract (Java 8 default/static methods are public)</li>
<li>Use Case: When classes share code/state vs When classes share behavior contract but differ in implementation</li>
</ul>
</li>
<li>
<p>SOLID</p>
</li>
<li>
<p>S - Single Responsibility Principle (SRP):</p>
<ul>
<li>A class should have only one reason to change.</li>
<li>One class = one responsibility = one axis of change.</li>
<li>E.g: OrderService only does Order, InvoiceService only does Invoice</li>
</ul>
</li>
<li>
<p>O — Open/Closed Principle (OCP)</p>
<ul>
<li>Classes should be open for extension, closed for modification.</li>
<li>Add new functionality by extending classes, not modifying them.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">interface PaymentMethod {
    void pay();
}

class CreditCardPayment implements PaymentMethod {
    public void pay() { /* ... */ }
}

class PayPalPayment implements PaymentMethod {
    public void pay() { /* ... */ }
}

class PaymentService {
    public void processPayment(PaymentMethod method) {
        method.pay();
    }
}
</code></pre>
<ul>
<li>L — Liskov Substitution Principle (LSP)</li>
</ul>
<pre><code class="language-java">abstract class Bird { }

interface Flyable {
    void fly();
}

class Sparrow extends Bird implements Flyable {
    public void fly() { /* ... */ }
}
</code></pre>
<ul>
<li>I — Interface Segregation Principle (ISP)
<ul>
<li>Clients should not be forced to depend on methods they don’t use.</li>
<li>Prefer multiple specific interfaces over one large interface.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Robot implements Workable {
    public void work() { /* ... */ }
}

class Human implements Workable, Eatable {
    public void work() { /* ... */ }
    public void eat() { /* ... */ }
}
</code></pre>
<ul>
<li>D — Dependency Inversion Principle (DIP)
<ul>
<li>High-level modules should not depend on low-level modules.</li>
<li>Both should depend on abstractions.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">interface Database {
    void saveOrder(Order order);
}

class MySQLDatabase implements Database {
    public void saveOrder(Order order) { /* ... */ }
}

class OrderService {
    private Database db;
    public OrderService(Database db) {
        this.db = db;
    }
    public void save(Order order) {
        db.saveOrder(order);
    }
}
</code></pre>
<h3>🛢 PostgreSQL</h3>
<ul>
<li>Schema design: normalization, indexing, constraints, partitioning</li>
<li>Performance: query optimization (EXPLAIN ANALYZE), caching strategies, connection pooling (HikariCP)</li>
<li>Advanced: JSONB support, full-text search, triggers, stored procedures</li>
<li>Scaling: Replication, sharding, and failover</li>
</ul>
<h2>🖼 Front-end</h2>
<h3>Node.js</h3>
<ul>
<li>Event Loop and Concurrency</li>
<li>Phases of Event Loop
<ul>
<li>Timers (setTimeout, setInterval callbacks)</li>
<li>Pending Callbacks</li>
<li>Idle, Prepare</li>
<li>Poll (I/O callbacks)</li>
<li>Check (setImmediate callbacks)</li>
<li>Close Callbacks</li>
</ul>
</li>
</ul>
<h3>⚛️ React</h3>
<ul>
<li>Architecture: Micro frontends (MFEs), independent deployability, cross-app communication</li>
<li>Patterns:
<ul>
<li>Component-driven design (Storybook, Atomic Design)</li>
<li>State management (Redux, Zustand, or React Query)</li>
<li>Code splitting, lazy loading, and performance optimization</li>
</ul>
</li>
<li>Testing: Unit (Jest), integration (React Testing Library), E2E (Playwright/Cypress)</li>
</ul>
<h3>🔗 GraphQL</h3>
<ul>
<li>Design: Schema-first vs. code-first, queries, mutations, subscriptions</li>
<li>Tooling: Apollo Client/Server, caching, batching</li>
<li>Security: Depth limiting, query complexity analysis</li>
<li>Performance: N+1 problem and dataloader pattern, persisted queries</li>
</ul>
<h2>☁️ 3. DevOps and Infrastructure</h2>
<h3>🔄 Harness CI/CD</h3>
<ul>
<li>Pipelines: Understand workflows, GitOps, triggers, rollback strategies</li>
<li>Templates and Reuse: Use of YAML templates, stages, and approval gates</li>
<li>Governance: RBAC, policy enforcement, secrets management</li>
<li>Integration: With artifact repositories (e.g., Artifactory), test tools, monitoring</li>
</ul>
<h3>☁️ AWS</h3>
<ul>
<li>Core services:
<ul>
<li>Compute: EC2, ECS/EKS, Lambda (for serverless microservices)</li>
<li>Networking: VPC, ALB/NLB, Route53, PrivateLink, NAT Gateways</li>
<li>Storage: S3, EBS, EFS</li>
<li>Databases: RDS (PostgreSQL), DynamoDB, ElastiCache</li>
</ul>
</li>
<li>Security: IAM roles/policies, security groups, KMS, secrets manager</li>
<li>DevOps on AWS: CloudWatch, CloudTrail, X-Ray, Systems Manager</li>
<li>IaC: Terraform vs. AWS CDK, CloudFormation</li>
</ul>
<h3>Solution Design</h3>
<ul>
<li>Key Goals
<ul>
<li>Scalability (handle growth in users/data).</li>
<li>Reliability (no data loss, fault-tolerant).</li>
<li>Performance (low latency, high throughput).</li>
<li>Maintainability (clean APIs, modular).</li>
<li>Cost efficiency (cloud vs on-prem trade-offs).</li>
</ul>
</li>
<li>Key Concepts
<ul>
<li>Horizontal vs vertical scaling</li>
<li>CAP Theorem (Consistency, Availability, Partition tolerance)</li>
<li>Latency vs throughput trade-offs</li>
<li>Load balancing, caching, databases, queues, storage</li>
</ul>
</li>
<li>High-Level Design Process
<ul>
<li>Clarify requirements (functional + non-functional)</li>
<li>Estimate scale (QPS, storage, bandwidth)</li>
<li>Define API contracts (input/output)</li>
<li>Choose architecture style (monolith, microservices, event-driven)</li>
<li>Design components (DB, cache, message broker, load balancer)</li>
<li>Plan data flows (read/write paths)</li>
<li>Handle failures (replication, retries, circuit breakers)</li>
<li>Security &#x26; compliance (auth, encryption, GDPR)</li>
<li>Monitoring &#x26; observability (logs, metrics, tracing)</li>
<li>Evolution &#x26; scaling strategy</li>
</ul>
</li>
<li>Core Building Block
<ul>
<li>Databases
<ul>
<li>SQL vs NoSQL</li>
<li>Sharding, replication, partitioning</li>
<li>Read/write patterns (CQRS, event sourcing)</li>
<li>Transactions (ACID) vs eventual consistency</li>
</ul>
</li>
<li>Caching
<ul>
<li>In-memory: Redis, Memcached</li>
<li>Patterns: write-through, write-behind, cache-aside</li>
<li>Cache invalidation strategies</li>
</ul>
</li>
<li>Message Brokers
<ul>
<li>Kafka (pub/sub, event streams)</li>
<li>RabbitMQ (work queues)</li>
<li>SQS, Pub/Sub (cloud)</li>
</ul>
</li>
<li>Load Balancing
<ul>
<li>L4 (TCP) vs L7 (HTTP)</li>
<li>Sticky sessions, consistent hashing</li>
<li>Global vs regional load balancers (CDN + GSLB)</li>
</ul>
</li>
<li>Storage
<ul>
<li>Object (S3), block (EBS), file (EFS)</li>
<li>Hot vs cold storage</li>
</ul>
</li>
</ul>
</li>
<li>Scalability Patterns
<ul>
<li>Horizontal scaling (stateless services)</li>
<li>Partitioning/sharding (e.g., user_id % N)</li>
<li>Database replication (leader/follower)</li>
<li>Event-driven microservices</li>
<li>CQRS (Command Query Responsibility Segregation)</li>
<li>Backpressure handling (rate limiting, bulkheads)</li>
</ul>
</li>
<li>Blue/Green &#x26; Canary deployments
<ul>
<li>What is it? Two identical production environments: Blue (current) and Green (new). Deploy new version to Green → switch traffic from Blue to Green (instant cutover).</li>
<li>Switch traffic to Green (DNS, load balancer, or routing change).</li>
<li>LaunchDarkly</li>
</ul>
</li>
<li>API Gateway + BFF (Backend For Frontend)
<ul>
<li>API Gateway: A single entry point for all client requests to backend services.</li>
<li>Handles:
<ul>
<li>Routing</li>
<li>Aggregation</li>
<li>Authentication/Authorization</li>
<li>Rate limiting</li>
<li>Caching</li>
<li>Logging/Monitoring</li>
</ul>
</li>
<li>Backend For Frontend (BFF)
<ul>
<li>Definition
<ul>
<li>A dedicated backend layer per frontend (e.g., Web, Mobile, Smart TV).</li>
<li>Tailors APIs to frontend-specific needs (data shape, latency, features).</li>
</ul>
</li>
<li>Why Use It?
<ul>
<li>Avoids over-fetching/under-fetching (common with mobile apps).</li>
<li>Allows separate release cycles for frontend and backend.</li>
<li>Simplifies frontend logic — no need to aggregate multiple microservice calls.</li>
</ul>
</li>
</ul>
</li>
<li>Front-end -> API Gateway -> BFF -> Microserivces -> return packages that front-end needs</li>
</ul>
</li>
<li>Backpressure handling (rate limiting, bulkheads)
<ul>
<li>What it is
<ul>
<li>Occurs when producers send data faster than consumers can process.</li>
<li>Leads to queue buildup, memory exhaustion, timeouts, or crashes.</li>
<li>Common in message queues (Kafka, RabbitMQ), HTTP APIs, streaming systems.</li>
</ul>
</li>
<li>Backpressure Handling Techniques
<ul>
<li>Rate Limiting
<ul>
<li>Restrict incoming requests to avoid overwhelming system.</li>
<li>Implemented at API Gateway, load balancer, or service level.</li>
</ul>
</li>
<li>Bulkheads
<ul>
<li>Isolate resources into compartments so failure in one doesn’t affect others.</li>
<li>Named after ship bulkheads (watertight compartments).</li>
<li>Separate thread pools / connection pools per client or feature.</li>
<li>Example: Reserve DB pool for payment service separate from analytics.</li>
</ul>
</li>
<li>Circuit Breakers
<ul>
<li>Open circuit when failures exceed threshold → block calls temporarily.</li>
<li>Allows system to recover without constant failing calls.</li>
<li>Often paired with retry + fallback mechanisms.</li>
</ul>
</li>
<li>Backpressure in Streaming (Reactive Systems)
<ul>
<li>Protocols like Reactive Streams or frameworks like Project Reactor, Akka implement pull-based flow control:</li>
</ul>
</li>
<li>Queue Length Monitoring
<ul>
<li>Monitor queue depth (Kafka lag, RabbitMQ queue length).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>FAQs</h2>
<h3>SQL vs NoSQL</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>SQL (Relational)</th>
<th>NoSQL (Non-relational)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Model</td>
<td>Tables with fixed schema</td>
<td>Document, key-value, columnar, or graph (flexible)</td>
</tr>
<tr>
<td>Consistency</td>
<td>Strong ACID transactions</td>
<td>Often eventual consistency (tunable)</td>
</tr>
<tr>
<td>Query Complexity</td>
<td>Supports joins, aggregations, complex queries</td>
<td>Limited joins; optimized for specific access patterns</td>
</tr>
<tr>
<td>Scalability</td>
<td>Vertical scaling (scale-up)</td>
<td>Horizontal scaling (sharding, scale-out)</td>
</tr>
<tr>
<td>Schema Evolution</td>
<td>Rigid; migrations required</td>
<td>Flexible; schema-less or dynamic</td>
</tr>
<tr>
<td>Use Cases</td>
<td>Financial systems, ERP, strong consistency needed</td>
<td>Real-time analytics, IoT, flexible evolving data</td>
</tr>
<tr>
<td>Maturity/Tooling</td>
<td>Mature ecosystem (ORMs, tools, drivers)</td>
<td>Newer, evolving ecosystem</td>
</tr>
<tr>
<td>Cost/Complexity</td>
<td>Can be costly to scale horizontally</td>
<td>Operational complexity in sharding &#x26; consistency</td>
</tr>
</tbody>
</table>
<h3>Monolith vs Microservices</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Monolith</th>
<th>Microservices</th>
</tr>
</thead>
<tbody>
<tr>
<td>Architecture</td>
<td>Single codebase &#x26; deployment</td>
<td>Multiple independent services</td>
</tr>
<tr>
<td>Development Speed</td>
<td>Fast to start; simple CI/CD</td>
<td>Independent teams; faster feature velocity at scale</td>
</tr>
<tr>
<td>Scalability</td>
<td>Scale entire app together</td>
<td>Scale services independently</td>
</tr>
<tr>
<td>Operational Complexity</td>
<td>Simple deployment, debugging, monitoring</td>
<td>Requires service discovery, API Gateway, observability</td>
</tr>
<tr>
<td>Team Size Fit</td>
<td>Small teams (startup phase)</td>
<td>Large teams (clear domain boundaries)</td>
</tr>
<tr>
<td>Data Consistency</td>
<td>Single DB → easy consistency</td>
<td>Distributed data → eventual consistency (Saga)</td>
</tr>
<tr>
<td>Tech Stack Choice</td>
<td>One tech stack</td>
<td>Polyglot per service possible</td>
</tr>
<tr>
<td>Failure Isolation</td>
<td>Failure affects whole system</td>
<td>Failures isolated per service</td>
</tr>
<tr>
<td>Migration Path</td>
<td>Can evolve into modular monolith, then microservices</td>
<td>Start microservices only if domain is complex</td>
</tr>
</tbody>
</table>
<h3>Vertical vs Horizontal</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Vertical Scaling (Scale Up)</th>
<th>Horizontal Scaling (Scale Out)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Definition</td>
<td>Add more resources (CPU, RAM, disk) to a single machine</td>
<td>Add more machines/nodes to distribute the load</td>
</tr>
<tr>
<td>Complexity</td>
<td>Simple to implement; minimal code changes</td>
<td>Requires distributed systems design (load balancing, sharding)</td>
</tr>
<tr>
<td>Hardware Limitations</td>
<td>Limited by max capacity of a single machine</td>
<td>Can scale almost infinitely by adding more nodes</td>
</tr>
<tr>
<td>Fault Tolerance</td>
<td>Single point of failure; if server fails, system down</td>
<td>High availability; other nodes handle failures</td>
</tr>
<tr>
<td>Cost</td>
<td>Expensive for high-end hardware (diminishing returns)</td>
<td>Cheaper commodity hardware; cost grows linearly</td>
</tr>
<tr>
<td>Data Management</td>
<td>Centralized; no data distribution required</td>
<td>Requires partitioning, replication, consistency management</td>
</tr>
<tr>
<td>Use Cases</td>
<td>Small/medium apps, early-stage startups</td>
<td>Large-scale apps, microservices, cloud-native systems</td>
</tr>
<tr>
<td>Example</td>
<td>Upgrading server from 8-core to 64-core CPU</td>
<td>Adding 10 servers behind a load balancer</td>
</tr>
</tbody>
</table>
</div></article><div class="flex flex-col gap-y-4 md:gap-y-8"><a href="/posts/career/principal-engineer/"><div class="relative overflow-hidden rounded-2xl border border-white/10 bg-white/5 p-6 shadow-xl shadow-black/30 backdrop-blur-lg transition-all duration-300 sm:p-8 flex flex-col gap-y-1 border-b border-neutral-800 py-4"><p class="m-0 p-0"><b>Principal Engineer</b></p><small>Date: <!-- -->2025-07-30</small></div></a><a href="/posts/career/resume/"><div class="relative overflow-hidden rounded-2xl border border-white/10 bg-white/5 p-6 shadow-xl shadow-black/30 backdrop-blur-lg transition-all duration-300 sm:p-8 flex flex-col gap-y-1 border-b border-neutral-800 py-4"><p class="m-0 p-0"><b>Resume</b></p><small>Date: <!-- -->2025-05-01</small></div></a><a href="/posts/career/computational-neuroscience/"><div class="relative overflow-hidden rounded-2xl border border-white/10 bg-white/5 p-6 shadow-xl shadow-black/30 backdrop-blur-lg transition-all duration-300 sm:p-8 flex flex-col gap-y-1 border-b border-neutral-800 py-4"><p class="m-0 p-0"><b>Computational Neuroscience</b></p><small>Date: <!-- -->2025-04-19</small></div></a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"career/principal-engineer","name":"Principal Engineer","title":"Principal Engineer","date":"2025-07-30","contentHtml":"\u003ch2\u003e📚 Table of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#-table-of-contents\"\u003e📚 Table of Contents\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-back-end\"\u003e🔧 Back-end\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#-microservices-architecture\"\u003e🧱 Microservices Architecture\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EF%B8%8F-apache-kafka\"\u003e⚙️ Apache Kafka\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EF%B8%8F-java--spring-boot\"\u003e☕️ Java + Spring Boot\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-postgresql\"\u003e🛢 PostgreSQL\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-front-end\"\u003e🖼 Front-end\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#nodejs\"\u003eNode.js\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EF%B8%8F-react\"\u003e⚛️ React\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#-graphql\"\u003e🔗 GraphQL\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EF%B8%8F-3-devops-and-infrastructure\"\u003e☁️ 3. DevOps and Infrastructure\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#-harness-cicd\"\u003e🔄 Harness CI/CD\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EF%B8%8F-aws\"\u003e☁️ AWS\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#solution-design\"\u003eSolution Design\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#faqs\"\u003eFAQs\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#sql-vs-nosql\"\u003eSQL vs NoSQL\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#monolith-vs-microservices\"\u003eMonolith vs Microservices\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#vertical-vs-horizontal\"\u003eVertical vs Horizontal\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e🔧 Back-end\u003c/h2\u003e\n\u003ch3\u003e🧱 Microservices Architecture\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCore Principles\n\u003cul\u003e\n\u003cli\u003eSingle Responsibility: Each service owns a bounded context (DDD).\u003c/li\u003e\n\u003cli\u003eLoose Coupling \u0026#x26; High Cohesion: Minimize dependencies, maximize internal focus.\u003c/li\u003e\n\u003cli\u003eAutonomy: Services deploy, scale, and evolve independently.\u003c/li\u003e\n\u003cli\u003eDecentralized Data Management: Each service manages its own database; avoid shared DB.\u003c/li\u003e\n\u003cli\u003eResiliency \u0026#x26; Observability: Circuit breakers, retries, metrics, tracing, logging.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBenefits\n\u003cul\u003e\n\u003cli\u003eIndependent deployments (CI/CD friendly).\u003c/li\u003e\n\u003cli\u003ePolyglot architecture (choose best tech per service).\u003c/li\u003e\n\u003cli\u003eFault isolation (failure in one service doesn’t cascade).\u003c/li\u003e\n\u003cli\u003eScalability per component (e.g., scale only order service).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eChallenges\n\u003cul\u003e\n\u003cli\u003eData consistency (distributed transactions).\u003c/li\u003e\n\u003cli\u003eOperational complexity (monitoring, debugging).\u003c/li\u003e\n\u003cli\u003eNetwork latency \u0026#x26; reliability (timeouts, retries).\u003c/li\u003e\n\u003cli\u003eDeployment orchestration (service discovery, configuration management).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDesign Patterns\n\u003cul\u003e\n\u003cli\u003eDatabase per service\u003c/li\u003e\n\u003cli\u003eCQRS (Command Query Responsibility Segregation)\u003c/li\u003e\n\u003cli\u003eEvent sourcing (capture state changes as immutable events)\u003c/li\u003e\n\u003cli\u003eStrangler Fig Pattern (incremental migration from monolith)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCommon questions\n\u003cul\u003e\n\u003cli\u003eWhat are the main challenges of microservices architecture? Hard to maintain consistency without 2PC. Use Saga/Event patterns.\n\u003cul\u003e\n\u003cli\u003e2PC (All for Nothing)\u003c/li\u003e\n\u003cli\u003eSaga Pattern\n\u003cul\u003e\n\u003cli\u003eBreak transaction into local transactions per service.\u003c/li\u003e\n\u003cli\u003eEach service publishes an event after completing its local action.\u003c/li\u003e\n\u003cli\u003eOther services react to events (Choreography) or are told what to do (Orchestration).\u003c/li\u003e\n\u003cli\u003eUse compensating actions to roll back (e.g., cancel payment if inventory fails).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eOperational complexity: Monitoring, logging, tracing across services? Use correlationId and Generate at API Gateway or entry service.\u003c/li\u003e\n\u003cli\u003eVersioning \u0026#x26; backward compatibility: Handle evolving contracts with API versioning and schema evolution.\u003c/li\u003e\n\u003cli\u003eBenefits of Orchestration\n\u003cul\u003e\n\u003cli\u003eCentralized Workflow Control (BPMN diagrams)\u003c/li\u003e\n\u003cli\u003eSimpler to reason about success/failure paths compared to multiple scattered events.\u003c/li\u003e\n\u003cli\u003eCan trigger compensating actions immediately when a step fails.\u003c/li\u003e\n\u003cli\u003eAvoids “event storming” where multiple services react redundantly.\u003c/li\u003e\n\u003cli\u003eFlexible Sequencing: Can reorder or skip steps without touching multiple services.\u003c/li\u003e\n\u003cli\u003eGood for complex workflows (e.g., multi-step approvals, conditional branching).\u003c/li\u003e\n\u003cli\u003eWhen to Prefer Orchestration\n\u003cul\u003e\n\u003cli\u003eComplex workflows with many steps or compensations.\u003c/li\u003e\n\u003cli\u003eDynamic flows (branching, conditional logic).\u003c/li\u003e\n\u003cli\u003eWhen you need auditability and monitoring of workflows.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eInbox / Outbox\n\u003cul\u003e\n\u003cli\u003eOutbox\n\u003cul\u003e\n\u003cli\u003eIn microservices, dual writes happen often:\n\u003cul\u003e\n\u003cli\u003eWrite to local DB (business state).\u003c/li\u003e\n\u003cli\u003ePublish event to message broker (Kafka/RabbitMQ).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eEnsure that when you update a database and publish an event, both happen atomically.\n\u003cul\u003e\n\u003cli\u003eHow It Works\n\u003cul\u003e\n\u003cli\u003eWhen processing a command, write both:\n\u003cul\u003e\n\u003cli\u003eBusiness data (e.g., order table)\u003c/li\u003e\n\u003cli\u003eEvent data (e.g., outbox table) into the same database transaction.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eA separate process (or Kafka Connect/Debezium) reads outbox table and publishes the event to Kafka.\u003c/li\u003e\n\u003cli\u003eAfter successful publish, mark outbox entry as processed (or delete).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBenefits\n\u003cul\u003e\n\u003cli\u003eGuarantees no lost events (DB and event always in sync).\u003c/li\u003e\n\u003cli\u003eAvoids dual write problem without 2PC.\u003c/li\u003e\n\u003cli\u003eWorks well with Kafka + relational DB.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTrade-offs\n\u003cul\u003e\n\u003cli\u003eExtra outbox table management (cleanup, indexes).\u003c/li\u003e\n\u003cli\u003eSlight latency between DB commit and event publish.\u003c/li\u003e\n\u003cli\u003eNeed idempotent consumers (events may be delivered at least once).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eInbox\n\u003cul\u003e\n\u003cli\u003eGoal\n\u003cul\u003e\n\u003cli\u003eEnsure idempotent event consumption (avoid double-processing events).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHow It Works\n\u003cul\u003e\n\u003cli\u003eConsumer stores event ID in inbox table when processing event.\u003c/li\u003e\n\u003cli\u003eBefore processing, check if event ID exists:\n\u003cul\u003e\n\u003cli\u003eIf exists → ignore (duplicate).\u003c/li\u003e\n\u003cli\u003eIf not → process and insert into inbox.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBenefits\n\u003cul\u003e\n\u003cli\u003eEnsures exactly-once processing in consumer.\u003c/li\u003e\n\u003cli\u003eProtects against replayed or duplicate messages.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTrade-offs\n\u003cul\u003e\n\u003cli\u003eRequires storage for inbox table.\u003c/li\u003e\n\u003cli\u003eMore DB writes on consumers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eKafka\n\u003cul\u003e\n\u003cli\u003eTopic\n\u003cul\u003e\n\u003cli\u003eA log-structured data stream.\u003c/li\u003e\n\u003cli\u003eAppend-only; events are immutable.\u003c/li\u003e\n\u003cli\u003eDivided into partitions → allows horizontal scaling and parallel consumption.\u003c/li\u003e\n\u003cli\u003eEach message has an offset (position in partition).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eConsumer Groups\n\u003cul\u003e\n\u003cli\u003eGroup of consumers sharing the same group ID.\u003c/li\u003e\n\u003cli\u003eKafka assigns partitions to consumers → ensures load balancing.\u003c/li\u003e\n\u003cli\u003eWithin a group:\n\u003cul\u003e\n\u003cli\u003eEach partition consumed by only one consumer (scales horizontally).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMultiple groups can consume the same topic independently (e.g., analytics vs billing).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eExamples\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eorder.events\u003c/code\u003e contains all order-related events: \u003ccode\u003eOrderCreated\u003c/code\u003e, \u003ccode\u003eOrderPaid\u003c/code\u003e, \u003ccode\u003eOrderShipped\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eevents are distributed by partition key (e.g., orderId):\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eRetention\n\u003cul\u003e\n\u003cli\u003eKafka stores events for a configurable period (e.g., 7 days).\u003c/li\u003e\n\u003cli\u003eConsumers can replay events by resetting offsets (great for recovery/debugging).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDelivery Semantics\n\u003cul\u003e\n\u003cli\u003eAt-least-once (default).\n\u003cul\u003e\n\u003cli\u003eEach message is delivered one or more times.\u003c/li\u003e\n\u003cli\u003eDuplicates may occur, but no message is lost.\u003c/li\u003e\n\u003cli\u003eConsumer processes message first, then commits offset (auto or manual).\u003c/li\u003e\n\u003cli\u003eIf crash happens after processing but before commit, message is re-delivered.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eAt-most-once (manual offset commit control).\n\u003cul\u003e\n\u003cli\u003eEach message is delivered zero or one time.\u003c/li\u003e\n\u003cli\u003eNo duplicates, but possible data loss.\u003c/li\u003e\n\u003cli\u003eCommit offset before processing message.\u003c/li\u003e\n\u003cli\u003eIf crash occurs after commit but before processing, message is lost.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eExactly-once (requires idempotent producers + transactional APIs).\n\u003cul\u003e\n\u003cli\u003eEach message is delivered once and only once (no duplicates, no loss).\u003c/li\u003e\n\u003cli\u003eIdempotent Producer (enable.idempotence=true) -\u003e ensures no duplicates during retries.\u003c/li\u003e\n\u003cli\u003eTransactional API -\u003e ensures atomic writes + offset commits.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eWhy Kafka is Popular in Microservices\n\u003cul\u003e\n\u003cli\u003eOffset\n\u003cul\u003e\n\u003cli\u003eOffset = sequential ID for each record within a partition.\u003c/li\u003e\n\u003cli\u003eStarts at 0, increments by 1 per message.\u003c/li\u003e\n\u003cli\u003eIdentifies a unique position in a partition.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHigh throughput + horizontal scalability (millions of messages/sec).\u003c/li\u003e\n\u003cli\u003eReplayability: Consumers can reprocess past events (e.g., rebuild state).\u003c/li\u003e\n\u003cli\u003eDecoupled architecture: Multiple consumers read same event independently.\u003c/li\u003e\n\u003cli\u003eEvent sourcing \u0026#x26; CQRS: Naturally supports state rebuild and projections.\n\u003cul\u003e\n\u003cli\u003eStore different states (Instead of storing order: {status: SHIPPED}, store: OrderCreated, OrderPaid, OrderShipped)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eStrong ordering within partitions: Good for workflows per entity (e.g., per order ID).\u003c/li\u003e\n\u003cli\u003eSchema Registry\n\u003cul\u003e\n\u003cli\u003eDefinition\n\u003cul\u003e\n\u003cli\u003eService that manages schemas (Avro, JSON Schema, Protobuf) for Kafka topics.\u003c/li\u003e\n\u003cli\u003eProducers and consumers register and validate schemas to ensure compatibility.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHow It Works\n\u003cul\u003e\n\u003cli\u003eEach schema gets an ID stored in Kafka message header.\u003c/li\u003e\n\u003cli\u003eConsumer fetches schema by ID → deserializes message correctly.\u003c/li\u003e\n\u003cli\u003eSupports schema evolution (backward/forward/full compatibility).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eKey points\n\u003cul\u003e\n\u003cli\u003eAlways add default values for new fields (avoid breaking old consumers).\u003c/li\u003e\n\u003cli\u003eAvoid removing fields — mark them as deprecated instead.\u003c/li\u003e\n\u003cli\u003eChoose compatibility mode based on rollout strategy (backward is safest).\u003c/li\u003e\n\u003cli\u003eUse Schema Registry’s versioning to manage multiple schema versions in parallel.\u003c/li\u003e\n\u003cli\u003eWhen using Kafka Connect or CDC, schemas evolve automatically with registry checks.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e⚙️ Apache Kafka\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eConcepts:\n\u003cul\u003e\n\u003cli\u003eTopics, partitions, consumer groups, offset management\u003c/li\u003e\n\u003cli\u003eAt-least-once vs. exactly-once semantics\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eUse Cases: Event sourcing, change data capture (CDC), stream processing\u003c/li\u003e\n\u003cli\u003eTools: Kafka Streams, Kafka Connect, schema registry (e.g., Avro with Confluent)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e☕️ Java + Spring Boot\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eCore knowledge:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSpring Boot Autoconfiguration, Profiles, Actuators\u003c/li\u003e\n\u003cli\u003eDependency injection with Spring Framework\u003c/li\u003e\n\u003cli\u003eException handling, validation, and AOP\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAdvanced topics:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSpring Cloud: Config, Discovery, Gateway\u003c/li\u003e\n\u003cli\u003eReactive programming (WebFlux) – especially with Kafka or streaming\u003c/li\u003e\n\u003cli\u003eObservability with Spring Boot: Micrometer, Prometheus, Zipkin\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDifference between abstract class and interface?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePurpose: Base class for related objects; partial implementation vs Contract/behavior without implementation\u003c/li\u003e\n\u003cli\u003eInheritance: A class can extend one abstract class vs A class can implement multiple interfaces\u003c/li\u003e\n\u003cli\u003eConstructor: Can define constructors (called by subclasses) vs No constructors (no state to initialize)\u003c/li\u003e\n\u003cli\u003eAccess Modifiers: Can use any (private, protected, etc.) vs All methods are implicitly public abstract (Java 8 default/static methods are public)\u003c/li\u003e\n\u003cli\u003eUse Case: When classes share code/state vs When classes share behavior contract but differ in implementation\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSOLID\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eS - Single Responsibility Principle (SRP):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA class should have only one reason to change.\u003c/li\u003e\n\u003cli\u003eOne class = one responsibility = one axis of change.\u003c/li\u003e\n\u003cli\u003eE.g: OrderService only does Order, InvoiceService only does Invoice\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eO — Open/Closed Principle (OCP)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eClasses should be open for extension, closed for modification.\u003c/li\u003e\n\u003cli\u003eAdd new functionality by extending classes, not modifying them.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003einterface PaymentMethod {\n    void pay();\n}\n\nclass CreditCardPayment implements PaymentMethod {\n    public void pay() { /* ... */ }\n}\n\nclass PayPalPayment implements PaymentMethod {\n    public void pay() { /* ... */ }\n}\n\nclass PaymentService {\n    public void processPayment(PaymentMethod method) {\n        method.pay();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eL — Liskov Substitution Principle (LSP)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eabstract class Bird { }\n\ninterface Flyable {\n    void fly();\n}\n\nclass Sparrow extends Bird implements Flyable {\n    public void fly() { /* ... */ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eI — Interface Segregation Principle (ISP)\n\u003cul\u003e\n\u003cli\u003eClients should not be forced to depend on methods they don’t use.\u003c/li\u003e\n\u003cli\u003ePrefer multiple specific interfaces over one large interface.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003einterface Workable {\n    void work();\n}\n\ninterface Eatable {\n    void eat();\n}\n\nclass Robot implements Workable {\n    public void work() { /* ... */ }\n}\n\nclass Human implements Workable, Eatable {\n    public void work() { /* ... */ }\n    public void eat() { /* ... */ }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eD — Dependency Inversion Principle (DIP)\n\u003cul\u003e\n\u003cli\u003eHigh-level modules should not depend on low-level modules.\u003c/li\u003e\n\u003cli\u003eBoth should depend on abstractions.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003einterface Database {\n    void saveOrder(Order order);\n}\n\nclass MySQLDatabase implements Database {\n    public void saveOrder(Order order) { /* ... */ }\n}\n\nclass OrderService {\n    private Database db;\n    public OrderService(Database db) {\n        this.db = db;\n    }\n    public void save(Order order) {\n        db.saveOrder(order);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e🛢 PostgreSQL\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eSchema design: normalization, indexing, constraints, partitioning\u003c/li\u003e\n\u003cli\u003ePerformance: query optimization (EXPLAIN ANALYZE), caching strategies, connection pooling (HikariCP)\u003c/li\u003e\n\u003cli\u003eAdvanced: JSONB support, full-text search, triggers, stored procedures\u003c/li\u003e\n\u003cli\u003eScaling: Replication, sharding, and failover\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e🖼 Front-end\u003c/h2\u003e\n\u003ch3\u003eNode.js\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eEvent Loop and Concurrency\u003c/li\u003e\n\u003cli\u003ePhases of Event Loop\n\u003cul\u003e\n\u003cli\u003eTimers (setTimeout, setInterval callbacks)\u003c/li\u003e\n\u003cli\u003ePending Callbacks\u003c/li\u003e\n\u003cli\u003eIdle, Prepare\u003c/li\u003e\n\u003cli\u003ePoll (I/O callbacks)\u003c/li\u003e\n\u003cli\u003eCheck (setImmediate callbacks)\u003c/li\u003e\n\u003cli\u003eClose Callbacks\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e⚛️ React\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eArchitecture: Micro frontends (MFEs), independent deployability, cross-app communication\u003c/li\u003e\n\u003cli\u003ePatterns:\n\u003cul\u003e\n\u003cli\u003eComponent-driven design (Storybook, Atomic Design)\u003c/li\u003e\n\u003cli\u003eState management (Redux, Zustand, or React Query)\u003c/li\u003e\n\u003cli\u003eCode splitting, lazy loading, and performance optimization\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTesting: Unit (Jest), integration (React Testing Library), E2E (Playwright/Cypress)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e🔗 GraphQL\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDesign: Schema-first vs. code-first, queries, mutations, subscriptions\u003c/li\u003e\n\u003cli\u003eTooling: Apollo Client/Server, caching, batching\u003c/li\u003e\n\u003cli\u003eSecurity: Depth limiting, query complexity analysis\u003c/li\u003e\n\u003cli\u003ePerformance: N+1 problem and dataloader pattern, persisted queries\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e☁️ 3. DevOps and Infrastructure\u003c/h2\u003e\n\u003ch3\u003e🔄 Harness CI/CD\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePipelines: Understand workflows, GitOps, triggers, rollback strategies\u003c/li\u003e\n\u003cli\u003eTemplates and Reuse: Use of YAML templates, stages, and approval gates\u003c/li\u003e\n\u003cli\u003eGovernance: RBAC, policy enforcement, secrets management\u003c/li\u003e\n\u003cli\u003eIntegration: With artifact repositories (e.g., Artifactory), test tools, monitoring\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e☁️ AWS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCore services:\n\u003cul\u003e\n\u003cli\u003eCompute: EC2, ECS/EKS, Lambda (for serverless microservices)\u003c/li\u003e\n\u003cli\u003eNetworking: VPC, ALB/NLB, Route53, PrivateLink, NAT Gateways\u003c/li\u003e\n\u003cli\u003eStorage: S3, EBS, EFS\u003c/li\u003e\n\u003cli\u003eDatabases: RDS (PostgreSQL), DynamoDB, ElastiCache\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSecurity: IAM roles/policies, security groups, KMS, secrets manager\u003c/li\u003e\n\u003cli\u003eDevOps on AWS: CloudWatch, CloudTrail, X-Ray, Systems Manager\u003c/li\u003e\n\u003cli\u003eIaC: Terraform vs. AWS CDK, CloudFormation\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eSolution Design\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKey Goals\n\u003cul\u003e\n\u003cli\u003eScalability (handle growth in users/data).\u003c/li\u003e\n\u003cli\u003eReliability (no data loss, fault-tolerant).\u003c/li\u003e\n\u003cli\u003ePerformance (low latency, high throughput).\u003c/li\u003e\n\u003cli\u003eMaintainability (clean APIs, modular).\u003c/li\u003e\n\u003cli\u003eCost efficiency (cloud vs on-prem trade-offs).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eKey Concepts\n\u003cul\u003e\n\u003cli\u003eHorizontal vs vertical scaling\u003c/li\u003e\n\u003cli\u003eCAP Theorem (Consistency, Availability, Partition tolerance)\u003c/li\u003e\n\u003cli\u003eLatency vs throughput trade-offs\u003c/li\u003e\n\u003cli\u003eLoad balancing, caching, databases, queues, storage\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHigh-Level Design Process\n\u003cul\u003e\n\u003cli\u003eClarify requirements (functional + non-functional)\u003c/li\u003e\n\u003cli\u003eEstimate scale (QPS, storage, bandwidth)\u003c/li\u003e\n\u003cli\u003eDefine API contracts (input/output)\u003c/li\u003e\n\u003cli\u003eChoose architecture style (monolith, microservices, event-driven)\u003c/li\u003e\n\u003cli\u003eDesign components (DB, cache, message broker, load balancer)\u003c/li\u003e\n\u003cli\u003ePlan data flows (read/write paths)\u003c/li\u003e\n\u003cli\u003eHandle failures (replication, retries, circuit breakers)\u003c/li\u003e\n\u003cli\u003eSecurity \u0026#x26; compliance (auth, encryption, GDPR)\u003c/li\u003e\n\u003cli\u003eMonitoring \u0026#x26; observability (logs, metrics, tracing)\u003c/li\u003e\n\u003cli\u003eEvolution \u0026#x26; scaling strategy\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCore Building Block\n\u003cul\u003e\n\u003cli\u003eDatabases\n\u003cul\u003e\n\u003cli\u003eSQL vs NoSQL\u003c/li\u003e\n\u003cli\u003eSharding, replication, partitioning\u003c/li\u003e\n\u003cli\u003eRead/write patterns (CQRS, event sourcing)\u003c/li\u003e\n\u003cli\u003eTransactions (ACID) vs eventual consistency\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCaching\n\u003cul\u003e\n\u003cli\u003eIn-memory: Redis, Memcached\u003c/li\u003e\n\u003cli\u003ePatterns: write-through, write-behind, cache-aside\u003c/li\u003e\n\u003cli\u003eCache invalidation strategies\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMessage Brokers\n\u003cul\u003e\n\u003cli\u003eKafka (pub/sub, event streams)\u003c/li\u003e\n\u003cli\u003eRabbitMQ (work queues)\u003c/li\u003e\n\u003cli\u003eSQS, Pub/Sub (cloud)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eLoad Balancing\n\u003cul\u003e\n\u003cli\u003eL4 (TCP) vs L7 (HTTP)\u003c/li\u003e\n\u003cli\u003eSticky sessions, consistent hashing\u003c/li\u003e\n\u003cli\u003eGlobal vs regional load balancers (CDN + GSLB)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eStorage\n\u003cul\u003e\n\u003cli\u003eObject (S3), block (EBS), file (EFS)\u003c/li\u003e\n\u003cli\u003eHot vs cold storage\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eScalability Patterns\n\u003cul\u003e\n\u003cli\u003eHorizontal scaling (stateless services)\u003c/li\u003e\n\u003cli\u003ePartitioning/sharding (e.g., user_id % N)\u003c/li\u003e\n\u003cli\u003eDatabase replication (leader/follower)\u003c/li\u003e\n\u003cli\u003eEvent-driven microservices\u003c/li\u003e\n\u003cli\u003eCQRS (Command Query Responsibility Segregation)\u003c/li\u003e\n\u003cli\u003eBackpressure handling (rate limiting, bulkheads)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBlue/Green \u0026#x26; Canary deployments\n\u003cul\u003e\n\u003cli\u003eWhat is it? Two identical production environments: Blue (current) and Green (new). Deploy new version to Green → switch traffic from Blue to Green (instant cutover).\u003c/li\u003e\n\u003cli\u003eSwitch traffic to Green (DNS, load balancer, or routing change).\u003c/li\u003e\n\u003cli\u003eLaunchDarkly\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eAPI Gateway + BFF (Backend For Frontend)\n\u003cul\u003e\n\u003cli\u003eAPI Gateway: A single entry point for all client requests to backend services.\u003c/li\u003e\n\u003cli\u003eHandles:\n\u003cul\u003e\n\u003cli\u003eRouting\u003c/li\u003e\n\u003cli\u003eAggregation\u003c/li\u003e\n\u003cli\u003eAuthentication/Authorization\u003c/li\u003e\n\u003cli\u003eRate limiting\u003c/li\u003e\n\u003cli\u003eCaching\u003c/li\u003e\n\u003cli\u003eLogging/Monitoring\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBackend For Frontend (BFF)\n\u003cul\u003e\n\u003cli\u003eDefinition\n\u003cul\u003e\n\u003cli\u003eA dedicated backend layer per frontend (e.g., Web, Mobile, Smart TV).\u003c/li\u003e\n\u003cli\u003eTailors APIs to frontend-specific needs (data shape, latency, features).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eWhy Use It?\n\u003cul\u003e\n\u003cli\u003eAvoids over-fetching/under-fetching (common with mobile apps).\u003c/li\u003e\n\u003cli\u003eAllows separate release cycles for frontend and backend.\u003c/li\u003e\n\u003cli\u003eSimplifies frontend logic — no need to aggregate multiple microservice calls.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eFront-end -\u003e API Gateway -\u003e BFF -\u003e Microserivces -\u003e return packages that front-end needs\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBackpressure handling (rate limiting, bulkheads)\n\u003cul\u003e\n\u003cli\u003eWhat it is\n\u003cul\u003e\n\u003cli\u003eOccurs when producers send data faster than consumers can process.\u003c/li\u003e\n\u003cli\u003eLeads to queue buildup, memory exhaustion, timeouts, or crashes.\u003c/li\u003e\n\u003cli\u003eCommon in message queues (Kafka, RabbitMQ), HTTP APIs, streaming systems.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBackpressure Handling Techniques\n\u003cul\u003e\n\u003cli\u003eRate Limiting\n\u003cul\u003e\n\u003cli\u003eRestrict incoming requests to avoid overwhelming system.\u003c/li\u003e\n\u003cli\u003eImplemented at API Gateway, load balancer, or service level.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBulkheads\n\u003cul\u003e\n\u003cli\u003eIsolate resources into compartments so failure in one doesn’t affect others.\u003c/li\u003e\n\u003cli\u003eNamed after ship bulkheads (watertight compartments).\u003c/li\u003e\n\u003cli\u003eSeparate thread pools / connection pools per client or feature.\u003c/li\u003e\n\u003cli\u003eExample: Reserve DB pool for payment service separate from analytics.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCircuit Breakers\n\u003cul\u003e\n\u003cli\u003eOpen circuit when failures exceed threshold → block calls temporarily.\u003c/li\u003e\n\u003cli\u003eAllows system to recover without constant failing calls.\u003c/li\u003e\n\u003cli\u003eOften paired with retry + fallback mechanisms.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBackpressure in Streaming (Reactive Systems)\n\u003cul\u003e\n\u003cli\u003eProtocols like Reactive Streams or frameworks like Project Reactor, Akka implement pull-based flow control:\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eQueue Length Monitoring\n\u003cul\u003e\n\u003cli\u003eMonitor queue depth (Kafka lag, RabbitMQ queue length).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eFAQs\u003c/h2\u003e\n\u003ch3\u003eSQL vs NoSQL\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eAspect\u003c/th\u003e\n\u003cth\u003eSQL (Relational)\u003c/th\u003e\n\u003cth\u003eNoSQL (Non-relational)\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eData Model\u003c/td\u003e\n\u003ctd\u003eTables with fixed schema\u003c/td\u003e\n\u003ctd\u003eDocument, key-value, columnar, or graph (flexible)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eConsistency\u003c/td\u003e\n\u003ctd\u003eStrong ACID transactions\u003c/td\u003e\n\u003ctd\u003eOften eventual consistency (tunable)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eQuery Complexity\u003c/td\u003e\n\u003ctd\u003eSupports joins, aggregations, complex queries\u003c/td\u003e\n\u003ctd\u003eLimited joins; optimized for specific access patterns\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eScalability\u003c/td\u003e\n\u003ctd\u003eVertical scaling (scale-up)\u003c/td\u003e\n\u003ctd\u003eHorizontal scaling (sharding, scale-out)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSchema Evolution\u003c/td\u003e\n\u003ctd\u003eRigid; migrations required\u003c/td\u003e\n\u003ctd\u003eFlexible; schema-less or dynamic\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eUse Cases\u003c/td\u003e\n\u003ctd\u003eFinancial systems, ERP, strong consistency needed\u003c/td\u003e\n\u003ctd\u003eReal-time analytics, IoT, flexible evolving data\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMaturity/Tooling\u003c/td\u003e\n\u003ctd\u003eMature ecosystem (ORMs, tools, drivers)\u003c/td\u003e\n\u003ctd\u003eNewer, evolving ecosystem\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCost/Complexity\u003c/td\u003e\n\u003ctd\u003eCan be costly to scale horizontally\u003c/td\u003e\n\u003ctd\u003eOperational complexity in sharding \u0026#x26; consistency\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eMonolith vs Microservices\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eAspect\u003c/th\u003e\n\u003cth\u003eMonolith\u003c/th\u003e\n\u003cth\u003eMicroservices\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eArchitecture\u003c/td\u003e\n\u003ctd\u003eSingle codebase \u0026#x26; deployment\u003c/td\u003e\n\u003ctd\u003eMultiple independent services\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDevelopment Speed\u003c/td\u003e\n\u003ctd\u003eFast to start; simple CI/CD\u003c/td\u003e\n\u003ctd\u003eIndependent teams; faster feature velocity at scale\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eScalability\u003c/td\u003e\n\u003ctd\u003eScale entire app together\u003c/td\u003e\n\u003ctd\u003eScale services independently\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eOperational Complexity\u003c/td\u003e\n\u003ctd\u003eSimple deployment, debugging, monitoring\u003c/td\u003e\n\u003ctd\u003eRequires service discovery, API Gateway, observability\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eTeam Size Fit\u003c/td\u003e\n\u003ctd\u003eSmall teams (startup phase)\u003c/td\u003e\n\u003ctd\u003eLarge teams (clear domain boundaries)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eData Consistency\u003c/td\u003e\n\u003ctd\u003eSingle DB → easy consistency\u003c/td\u003e\n\u003ctd\u003eDistributed data → eventual consistency (Saga)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eTech Stack Choice\u003c/td\u003e\n\u003ctd\u003eOne tech stack\u003c/td\u003e\n\u003ctd\u003ePolyglot per service possible\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eFailure Isolation\u003c/td\u003e\n\u003ctd\u003eFailure affects whole system\u003c/td\u003e\n\u003ctd\u003eFailures isolated per service\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMigration Path\u003c/td\u003e\n\u003ctd\u003eCan evolve into modular monolith, then microservices\u003c/td\u003e\n\u003ctd\u003eStart microservices only if domain is complex\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eVertical vs Horizontal\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eAspect\u003c/th\u003e\n\u003cth\u003eVertical Scaling (Scale Up)\u003c/th\u003e\n\u003cth\u003eHorizontal Scaling (Scale Out)\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eDefinition\u003c/td\u003e\n\u003ctd\u003eAdd more resources (CPU, RAM, disk) to a single machine\u003c/td\u003e\n\u003ctd\u003eAdd more machines/nodes to distribute the load\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eComplexity\u003c/td\u003e\n\u003ctd\u003eSimple to implement; minimal code changes\u003c/td\u003e\n\u003ctd\u003eRequires distributed systems design (load balancing, sharding)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eHardware Limitations\u003c/td\u003e\n\u003ctd\u003eLimited by max capacity of a single machine\u003c/td\u003e\n\u003ctd\u003eCan scale almost infinitely by adding more nodes\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eFault Tolerance\u003c/td\u003e\n\u003ctd\u003eSingle point of failure; if server fails, system down\u003c/td\u003e\n\u003ctd\u003eHigh availability; other nodes handle failures\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCost\u003c/td\u003e\n\u003ctd\u003eExpensive for high-end hardware (diminishing returns)\u003c/td\u003e\n\u003ctd\u003eCheaper commodity hardware; cost grows linearly\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eData Management\u003c/td\u003e\n\u003ctd\u003eCentralized; no data distribution required\u003c/td\u003e\n\u003ctd\u003eRequires partitioning, replication, consistency management\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eUse Cases\u003c/td\u003e\n\u003ctd\u003eSmall/medium apps, early-stage startups\u003c/td\u003e\n\u003ctd\u003eLarge-scale apps, microservices, cloud-native systems\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eExample\u003c/td\u003e\n\u003ctd\u003eUpgrading server from 8-core to 64-core CPU\u003c/td\u003e\n\u003ctd\u003eAdding 10 servers behind a load balancer\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n"},"relatedPosts":[{"id":"career/principal-engineer","title":"Principal Engineer","date":"2025-07-30"},{"id":"career/resume","title":"Resume","date":"2025-05-01"},{"id":"career/computational-neuroscience","title":"Computational Neuroscience","date":"2025-04-19"}]},"__N_SSG":true},"page":"/posts/[...id]","query":{"id":["career","principal-engineer"]},"buildId":"kmI-DEJGyjj_qX9Ur3MzG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>