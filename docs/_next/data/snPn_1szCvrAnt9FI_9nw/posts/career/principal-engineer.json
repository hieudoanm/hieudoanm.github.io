{"pageProps":{"postData":{"id":"career/principal-engineer","name":"Principal Engineer","title":"Principal Engineer","date":"2025-07-30","contentHtml":"<h2>üìö Table of Contents</h2>\n<ul>\n<li><a href=\"#-table-of-contents\">üìö Table of Contents</a></li>\n<li><a href=\"#-back-end\">üîß Back-end</a>\n<ul>\n<li><a href=\"#-microservices-architecture\">üß± Microservices Architecture</a></li>\n<li><a href=\"#%EF%B8%8F-apache-kafka\">‚öôÔ∏è Apache Kafka</a></li>\n<li><a href=\"#%EF%B8%8F-java--spring-boot\">‚òïÔ∏è Java + Spring Boot</a></li>\n<li><a href=\"#-postgresql\">üõ¢ PostgreSQL</a></li>\n</ul>\n</li>\n<li><a href=\"#-front-end\">üñº Front-end</a>\n<ul>\n<li><a href=\"#nodejs\">Node.js</a></li>\n<li><a href=\"#%EF%B8%8F-react\">‚öõÔ∏è React</a></li>\n<li><a href=\"#-graphql\">üîó GraphQL</a></li>\n</ul>\n</li>\n<li><a href=\"#%EF%B8%8F-3-devops-and-infrastructure\">‚òÅÔ∏è 3. DevOps and Infrastructure</a>\n<ul>\n<li><a href=\"#-harness-cicd\">üîÑ Harness CI/CD</a></li>\n<li><a href=\"#%EF%B8%8F-aws\">‚òÅÔ∏è AWS</a></li>\n<li><a href=\"#solution-design\">Solution Design</a></li>\n</ul>\n</li>\n<li><a href=\"#faqs\">FAQs</a>\n<ul>\n<li><a href=\"#sql-vs-nosql\">SQL vs NoSQL</a></li>\n<li><a href=\"#monolith-vs-microservices\">Monolith vs Microservices</a></li>\n<li><a href=\"#vertical-vs-horizontal\">Vertical vs Horizontal</a></li>\n</ul>\n</li>\n</ul>\n<h2>üîß Back-end</h2>\n<h3>üß± Microservices Architecture</h3>\n<ul>\n<li>Core Principles\n<ul>\n<li>Single Responsibility: Each service owns a bounded context (DDD).</li>\n<li>Loose Coupling &#x26; High Cohesion: Minimize dependencies, maximize internal focus.</li>\n<li>Autonomy: Services deploy, scale, and evolve independently.</li>\n<li>Decentralized Data Management: Each service manages its own database; avoid shared DB.</li>\n<li>Resiliency &#x26; Observability: Circuit breakers, retries, metrics, tracing, logging.</li>\n</ul>\n</li>\n<li>Benefits\n<ul>\n<li>Independent deployments (CI/CD friendly).</li>\n<li>Polyglot architecture (choose best tech per service).</li>\n<li>Fault isolation (failure in one service doesn‚Äôt cascade).</li>\n<li>Scalability per component (e.g., scale only order service).</li>\n</ul>\n</li>\n<li>Challenges\n<ul>\n<li>Data consistency (distributed transactions).</li>\n<li>Operational complexity (monitoring, debugging).</li>\n<li>Network latency &#x26; reliability (timeouts, retries).</li>\n<li>Deployment orchestration (service discovery, configuration management).</li>\n</ul>\n</li>\n<li>Design Patterns\n<ul>\n<li>Database per service</li>\n<li>CQRS (Command Query Responsibility Segregation)</li>\n<li>Event sourcing (capture state changes as immutable events)</li>\n<li>Strangler Fig Pattern (incremental migration from monolith)</li>\n</ul>\n</li>\n<li>Common questions\n<ul>\n<li>What are the main challenges of microservices architecture? Hard to maintain consistency without 2PC. Use Saga/Event patterns.\n<ul>\n<li>2PC (All for Nothing)</li>\n<li>Saga Pattern\n<ul>\n<li>Break transaction into local transactions per service.</li>\n<li>Each service publishes an event after completing its local action.</li>\n<li>Other services react to events (Choreography) or are told what to do (Orchestration).</li>\n<li>Use compensating actions to roll back (e.g., cancel payment if inventory fails).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Operational complexity: Monitoring, logging, tracing across services? Use correlationId and Generate at API Gateway or entry service.</li>\n<li>Versioning &#x26; backward compatibility: Handle evolving contracts with API versioning and schema evolution.</li>\n<li>Benefits of Orchestration\n<ul>\n<li>Centralized Workflow Control (BPMN diagrams)</li>\n<li>Simpler to reason about success/failure paths compared to multiple scattered events.</li>\n<li>Can trigger compensating actions immediately when a step fails.</li>\n<li>Avoids ‚Äúevent storming‚Äù where multiple services react redundantly.</li>\n<li>Flexible Sequencing: Can reorder or skip steps without touching multiple services.</li>\n<li>Good for complex workflows (e.g., multi-step approvals, conditional branching).</li>\n<li>When to Prefer Orchestration\n<ul>\n<li>Complex workflows with many steps or compensations.</li>\n<li>Dynamic flows (branching, conditional logic).</li>\n<li>When you need auditability and monitoring of workflows.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Inbox / Outbox\n<ul>\n<li>Outbox\n<ul>\n<li>In microservices, dual writes happen often:\n<ul>\n<li>Write to local DB (business state).</li>\n<li>Publish event to message broker (Kafka/RabbitMQ).</li>\n</ul>\n</li>\n<li>Ensure that when you update a database and publish an event, both happen atomically.\n<ul>\n<li>How It Works\n<ul>\n<li>When processing a command, write both:\n<ul>\n<li>Business data (e.g., order table)</li>\n<li>Event data (e.g., outbox table) into the same database transaction.</li>\n</ul>\n</li>\n<li>A separate process (or Kafka Connect/Debezium) reads outbox table and publishes the event to Kafka.</li>\n<li>After successful publish, mark outbox entry as processed (or delete).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Benefits\n<ul>\n<li>Guarantees no lost events (DB and event always in sync).</li>\n<li>Avoids dual write problem without 2PC.</li>\n<li>Works well with Kafka + relational DB.</li>\n</ul>\n</li>\n<li>Trade-offs\n<ul>\n<li>Extra outbox table management (cleanup, indexes).</li>\n<li>Slight latency between DB commit and event publish.</li>\n<li>Need idempotent consumers (events may be delivered at least once).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Inbox\n<ul>\n<li>Goal\n<ul>\n<li>Ensure idempotent event consumption (avoid double-processing events).</li>\n</ul>\n</li>\n<li>How It Works\n<ul>\n<li>Consumer stores event ID in inbox table when processing event.</li>\n<li>Before processing, check if event ID exists:\n<ul>\n<li>If exists ‚Üí ignore (duplicate).</li>\n<li>If not ‚Üí process and insert into inbox.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Benefits\n<ul>\n<li>Ensures exactly-once processing in consumer.</li>\n<li>Protects against replayed or duplicate messages.</li>\n</ul>\n</li>\n<li>Trade-offs\n<ul>\n<li>Requires storage for inbox table.</li>\n<li>More DB writes on consumers.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Kafka\n<ul>\n<li>Topic\n<ul>\n<li>A log-structured data stream.</li>\n<li>Append-only; events are immutable.</li>\n<li>Divided into partitions ‚Üí allows horizontal scaling and parallel consumption.</li>\n<li>Each message has an offset (position in partition).</li>\n</ul>\n</li>\n<li>Consumer Groups\n<ul>\n<li>Group of consumers sharing the same group ID.</li>\n<li>Kafka assigns partitions to consumers ‚Üí ensures load balancing.</li>\n<li>Within a group:\n<ul>\n<li>Each partition consumed by only one consumer (scales horizontally).</li>\n</ul>\n</li>\n<li>Multiple groups can consume the same topic independently (e.g., analytics vs billing).</li>\n</ul>\n</li>\n<li>Examples\n<ul>\n<li><code>order.events</code> contains all order-related events: <code>OrderCreated</code>, <code>OrderPaid</code>, <code>OrderShipped</code>.</li>\n<li>events are distributed by partition key (e.g., orderId):</li>\n</ul>\n</li>\n<li>Retention\n<ul>\n<li>Kafka stores events for a configurable period (e.g., 7 days).</li>\n<li>Consumers can replay events by resetting offsets (great for recovery/debugging).</li>\n</ul>\n</li>\n<li>Delivery Semantics\n<ul>\n<li>At-least-once (default).\n<ul>\n<li>Each message is delivered one or more times.</li>\n<li>Duplicates may occur, but no message is lost.</li>\n<li>Consumer processes message first, then commits offset (auto or manual).</li>\n<li>If crash happens after processing but before commit, message is re-delivered.</li>\n</ul>\n</li>\n<li>At-most-once (manual offset commit control).\n<ul>\n<li>Each message is delivered zero or one time.</li>\n<li>No duplicates, but possible data loss.</li>\n<li>Commit offset before processing message.</li>\n<li>If crash occurs after commit but before processing, message is lost.</li>\n</ul>\n</li>\n<li>Exactly-once (requires idempotent producers + transactional APIs).\n<ul>\n<li>Each message is delivered once and only once (no duplicates, no loss).</li>\n<li>Idempotent Producer (enable.idempotence=true) -> ensures no duplicates during retries.</li>\n<li>Transactional API -> ensures atomic writes + offset commits.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Why Kafka is Popular in Microservices\n<ul>\n<li>Offset\n<ul>\n<li>Offset = sequential ID for each record within a partition.</li>\n<li>Starts at 0, increments by 1 per message.</li>\n<li>Identifies a unique position in a partition.</li>\n</ul>\n</li>\n<li>High throughput + horizontal scalability (millions of messages/sec).</li>\n<li>Replayability: Consumers can reprocess past events (e.g., rebuild state).</li>\n<li>Decoupled architecture: Multiple consumers read same event independently.</li>\n<li>Event sourcing &#x26; CQRS: Naturally supports state rebuild and projections.\n<ul>\n<li>Store different states (Instead of storing order: {status: SHIPPED}, store: OrderCreated, OrderPaid, OrderShipped)</li>\n</ul>\n</li>\n<li>Strong ordering within partitions: Good for workflows per entity (e.g., per order ID).</li>\n<li>Schema Registry\n<ul>\n<li>Definition\n<ul>\n<li>Service that manages schemas (Avro, JSON Schema, Protobuf) for Kafka topics.</li>\n<li>Producers and consumers register and validate schemas to ensure compatibility.</li>\n</ul>\n</li>\n<li>How It Works\n<ul>\n<li>Each schema gets an ID stored in Kafka message header.</li>\n<li>Consumer fetches schema by ID ‚Üí deserializes message correctly.</li>\n<li>Supports schema evolution (backward/forward/full compatibility).</li>\n</ul>\n</li>\n<li>Key points\n<ul>\n<li>Always add default values for new fields (avoid breaking old consumers).</li>\n<li>Avoid removing fields ‚Äî mark them as deprecated instead.</li>\n<li>Choose compatibility mode based on rollout strategy (backward is safest).</li>\n<li>Use Schema Registry‚Äôs versioning to manage multiple schema versions in parallel.</li>\n<li>When using Kafka Connect or CDC, schemas evolve automatically with registry checks.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>‚öôÔ∏è Apache Kafka</h3>\n<ul>\n<li>Concepts:\n<ul>\n<li>Topics, partitions, consumer groups, offset management</li>\n<li>At-least-once vs. exactly-once semantics</li>\n</ul>\n</li>\n<li>Use Cases: Event sourcing, change data capture (CDC), stream processing</li>\n<li>Tools: Kafka Streams, Kafka Connect, schema registry (e.g., Avro with Confluent)</li>\n</ul>\n<h3>‚òïÔ∏è Java + Spring Boot</h3>\n<ul>\n<li>\n<p>Core knowledge:</p>\n<ul>\n<li>Spring Boot Autoconfiguration, Profiles, Actuators</li>\n<li>Dependency injection with Spring Framework</li>\n<li>Exception handling, validation, and AOP</li>\n</ul>\n</li>\n<li>\n<p>Advanced topics:</p>\n<ul>\n<li>Spring Cloud: Config, Discovery, Gateway</li>\n<li>Reactive programming (WebFlux) ‚Äì especially with Kafka or streaming</li>\n<li>Observability with Spring Boot: Micrometer, Prometheus, Zipkin</li>\n</ul>\n</li>\n<li>\n<p>Difference between abstract class and interface?</p>\n<ul>\n<li>Purpose: Base class for related objects; partial implementation vs Contract/behavior without implementation</li>\n<li>Inheritance: A class can extend one abstract class vs A class can implement multiple interfaces</li>\n<li>Constructor: Can define constructors (called by subclasses) vs No constructors (no state to initialize)</li>\n<li>Access Modifiers: Can use any (private, protected, etc.) vs All methods are implicitly public abstract (Java 8 default/static methods are public)</li>\n<li>Use Case: When classes share code/state vs When classes share behavior contract but differ in implementation</li>\n</ul>\n</li>\n<li>\n<p>SOLID</p>\n</li>\n<li>\n<p>S - Single Responsibility Principle (SRP):</p>\n<ul>\n<li>A class should have only one reason to change.</li>\n<li>One class = one responsibility = one axis of change.</li>\n<li>E.g: OrderService only does Order, InvoiceService only does Invoice</li>\n</ul>\n</li>\n<li>\n<p>O ‚Äî Open/Closed Principle (OCP)</p>\n<ul>\n<li>Classes should be open for extension, closed for modification.</li>\n<li>Add new functionality by extending classes, not modifying them.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">interface PaymentMethod {\n    void pay();\n}\n\nclass CreditCardPayment implements PaymentMethod {\n    public void pay() { /* ... */ }\n}\n\nclass PayPalPayment implements PaymentMethod {\n    public void pay() { /* ... */ }\n}\n\nclass PaymentService {\n    public void processPayment(PaymentMethod method) {\n        method.pay();\n    }\n}\n</code></pre>\n<ul>\n<li>L ‚Äî Liskov Substitution Principle (LSP)</li>\n</ul>\n<pre><code class=\"language-java\">abstract class Bird { }\n\ninterface Flyable {\n    void fly();\n}\n\nclass Sparrow extends Bird implements Flyable {\n    public void fly() { /* ... */ }\n}\n</code></pre>\n<ul>\n<li>I ‚Äî Interface Segregation Principle (ISP)\n<ul>\n<li>Clients should not be forced to depend on methods they don‚Äôt use.</li>\n<li>Prefer multiple specific interfaces over one large interface.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">interface Workable {\n    void work();\n}\n\ninterface Eatable {\n    void eat();\n}\n\nclass Robot implements Workable {\n    public void work() { /* ... */ }\n}\n\nclass Human implements Workable, Eatable {\n    public void work() { /* ... */ }\n    public void eat() { /* ... */ }\n}\n</code></pre>\n<ul>\n<li>D ‚Äî Dependency Inversion Principle (DIP)\n<ul>\n<li>High-level modules should not depend on low-level modules.</li>\n<li>Both should depend on abstractions.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-java\">interface Database {\n    void saveOrder(Order order);\n}\n\nclass MySQLDatabase implements Database {\n    public void saveOrder(Order order) { /* ... */ }\n}\n\nclass OrderService {\n    private Database db;\n    public OrderService(Database db) {\n        this.db = db;\n    }\n    public void save(Order order) {\n        db.saveOrder(order);\n    }\n}\n</code></pre>\n<h3>üõ¢ PostgreSQL</h3>\n<ul>\n<li>Schema design: normalization, indexing, constraints, partitioning</li>\n<li>Performance: query optimization (EXPLAIN ANALYZE), caching strategies, connection pooling (HikariCP)</li>\n<li>Advanced: JSONB support, full-text search, triggers, stored procedures</li>\n<li>Scaling: Replication, sharding, and failover</li>\n</ul>\n<h2>üñº Front-end</h2>\n<h3>Node.js</h3>\n<ul>\n<li>Event Loop and Concurrency</li>\n<li>Phases of Event Loop\n<ul>\n<li>Timers (setTimeout, setInterval callbacks)</li>\n<li>Pending Callbacks</li>\n<li>Idle, Prepare</li>\n<li>Poll (I/O callbacks)</li>\n<li>Check (setImmediate callbacks)</li>\n<li>Close Callbacks</li>\n</ul>\n</li>\n</ul>\n<h3>‚öõÔ∏è React</h3>\n<ul>\n<li>Architecture: Micro frontends (MFEs), independent deployability, cross-app communication</li>\n<li>Patterns:\n<ul>\n<li>Component-driven design (Storybook, Atomic Design)</li>\n<li>State management (Redux, Zustand, or React Query)</li>\n<li>Code splitting, lazy loading, and performance optimization</li>\n</ul>\n</li>\n<li>Testing: Unit (Jest), integration (React Testing Library), E2E (Playwright/Cypress)</li>\n</ul>\n<h3>üîó GraphQL</h3>\n<ul>\n<li>Design: Schema-first vs. code-first, queries, mutations, subscriptions</li>\n<li>Tooling: Apollo Client/Server, caching, batching</li>\n<li>Security: Depth limiting, query complexity analysis</li>\n<li>Performance: N+1 problem and dataloader pattern, persisted queries</li>\n</ul>\n<h2>‚òÅÔ∏è 3. DevOps and Infrastructure</h2>\n<h3>üîÑ Harness CI/CD</h3>\n<ul>\n<li>Pipelines: Understand workflows, GitOps, triggers, rollback strategies</li>\n<li>Templates and Reuse: Use of YAML templates, stages, and approval gates</li>\n<li>Governance: RBAC, policy enforcement, secrets management</li>\n<li>Integration: With artifact repositories (e.g., Artifactory), test tools, monitoring</li>\n</ul>\n<h3>‚òÅÔ∏è AWS</h3>\n<ul>\n<li>Core services:\n<ul>\n<li>Compute: EC2, ECS/EKS, Lambda (for serverless microservices)</li>\n<li>Networking: VPC, ALB/NLB, Route53, PrivateLink, NAT Gateways</li>\n<li>Storage: S3, EBS, EFS</li>\n<li>Databases: RDS (PostgreSQL), DynamoDB, ElastiCache</li>\n</ul>\n</li>\n<li>Security: IAM roles/policies, security groups, KMS, secrets manager</li>\n<li>DevOps on AWS: CloudWatch, CloudTrail, X-Ray, Systems Manager</li>\n<li>IaC: Terraform vs. AWS CDK, CloudFormation</li>\n</ul>\n<h3>Solution Design</h3>\n<ul>\n<li>Key Goals\n<ul>\n<li>Scalability (handle growth in users/data).</li>\n<li>Reliability (no data loss, fault-tolerant).</li>\n<li>Performance (low latency, high throughput).</li>\n<li>Maintainability (clean APIs, modular).</li>\n<li>Cost efficiency (cloud vs on-prem trade-offs).</li>\n</ul>\n</li>\n<li>Key Concepts\n<ul>\n<li>Horizontal vs vertical scaling</li>\n<li>CAP Theorem (Consistency, Availability, Partition tolerance)</li>\n<li>Latency vs throughput trade-offs</li>\n<li>Load balancing, caching, databases, queues, storage</li>\n</ul>\n</li>\n<li>High-Level Design Process\n<ul>\n<li>Clarify requirements (functional + non-functional)</li>\n<li>Estimate scale (QPS, storage, bandwidth)</li>\n<li>Define API contracts (input/output)</li>\n<li>Choose architecture style (monolith, microservices, event-driven)</li>\n<li>Design components (DB, cache, message broker, load balancer)</li>\n<li>Plan data flows (read/write paths)</li>\n<li>Handle failures (replication, retries, circuit breakers)</li>\n<li>Security &#x26; compliance (auth, encryption, GDPR)</li>\n<li>Monitoring &#x26; observability (logs, metrics, tracing)</li>\n<li>Evolution &#x26; scaling strategy</li>\n</ul>\n</li>\n<li>Core Building Block\n<ul>\n<li>Databases\n<ul>\n<li>SQL vs NoSQL</li>\n<li>Sharding, replication, partitioning</li>\n<li>Read/write patterns (CQRS, event sourcing)</li>\n<li>Transactions (ACID) vs eventual consistency</li>\n</ul>\n</li>\n<li>Caching\n<ul>\n<li>In-memory: Redis, Memcached</li>\n<li>Patterns: write-through, write-behind, cache-aside</li>\n<li>Cache invalidation strategies</li>\n</ul>\n</li>\n<li>Message Brokers\n<ul>\n<li>Kafka (pub/sub, event streams)</li>\n<li>RabbitMQ (work queues)</li>\n<li>SQS, Pub/Sub (cloud)</li>\n</ul>\n</li>\n<li>Load Balancing\n<ul>\n<li>L4 (TCP) vs L7 (HTTP)</li>\n<li>Sticky sessions, consistent hashing</li>\n<li>Global vs regional load balancers (CDN + GSLB)</li>\n</ul>\n</li>\n<li>Storage\n<ul>\n<li>Object (S3), block (EBS), file (EFS)</li>\n<li>Hot vs cold storage</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Scalability Patterns\n<ul>\n<li>Horizontal scaling (stateless services)</li>\n<li>Partitioning/sharding (e.g., user_id % N)</li>\n<li>Database replication (leader/follower)</li>\n<li>Event-driven microservices</li>\n<li>CQRS (Command Query Responsibility Segregation)</li>\n<li>Backpressure handling (rate limiting, bulkheads)</li>\n</ul>\n</li>\n<li>Blue/Green &#x26; Canary deployments\n<ul>\n<li>What is it? Two identical production environments: Blue (current) and Green (new). Deploy new version to Green ‚Üí switch traffic from Blue to Green (instant cutover).</li>\n<li>Switch traffic to Green (DNS, load balancer, or routing change).</li>\n<li>LaunchDarkly</li>\n</ul>\n</li>\n<li>API Gateway + BFF (Backend For Frontend)\n<ul>\n<li>API Gateway: A single entry point for all client requests to backend services.</li>\n<li>Handles:\n<ul>\n<li>Routing</li>\n<li>Aggregation</li>\n<li>Authentication/Authorization</li>\n<li>Rate limiting</li>\n<li>Caching</li>\n<li>Logging/Monitoring</li>\n</ul>\n</li>\n<li>Backend For Frontend (BFF)\n<ul>\n<li>Definition\n<ul>\n<li>A dedicated backend layer per frontend (e.g., Web, Mobile, Smart TV).</li>\n<li>Tailors APIs to frontend-specific needs (data shape, latency, features).</li>\n</ul>\n</li>\n<li>Why Use It?\n<ul>\n<li>Avoids over-fetching/under-fetching (common with mobile apps).</li>\n<li>Allows separate release cycles for frontend and backend.</li>\n<li>Simplifies frontend logic ‚Äî no need to aggregate multiple microservice calls.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Front-end -> API Gateway -> BFF -> Microserivces -> return packages that front-end needs</li>\n</ul>\n</li>\n<li>Backpressure handling (rate limiting, bulkheads)\n<ul>\n<li>What it is\n<ul>\n<li>Occurs when producers send data faster than consumers can process.</li>\n<li>Leads to queue buildup, memory exhaustion, timeouts, or crashes.</li>\n<li>Common in message queues (Kafka, RabbitMQ), HTTP APIs, streaming systems.</li>\n</ul>\n</li>\n<li>Backpressure Handling Techniques\n<ul>\n<li>Rate Limiting\n<ul>\n<li>Restrict incoming requests to avoid overwhelming system.</li>\n<li>Implemented at API Gateway, load balancer, or service level.</li>\n</ul>\n</li>\n<li>Bulkheads\n<ul>\n<li>Isolate resources into compartments so failure in one doesn‚Äôt affect others.</li>\n<li>Named after ship bulkheads (watertight compartments).</li>\n<li>Separate thread pools / connection pools per client or feature.</li>\n<li>Example: Reserve DB pool for payment service separate from analytics.</li>\n</ul>\n</li>\n<li>Circuit Breakers\n<ul>\n<li>Open circuit when failures exceed threshold ‚Üí block calls temporarily.</li>\n<li>Allows system to recover without constant failing calls.</li>\n<li>Often paired with retry + fallback mechanisms.</li>\n</ul>\n</li>\n<li>Backpressure in Streaming (Reactive Systems)\n<ul>\n<li>Protocols like Reactive Streams or frameworks like Project Reactor, Akka implement pull-based flow control:</li>\n</ul>\n</li>\n<li>Queue Length Monitoring\n<ul>\n<li>Monitor queue depth (Kafka lag, RabbitMQ queue length).</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>FAQs</h2>\n<h3>SQL vs NoSQL</h3>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>SQL (Relational)</th>\n<th>NoSQL (Non-relational)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Data Model</td>\n<td>Tables with fixed schema</td>\n<td>Document, key-value, columnar, or graph (flexible)</td>\n</tr>\n<tr>\n<td>Consistency</td>\n<td>Strong ACID transactions</td>\n<td>Often eventual consistency (tunable)</td>\n</tr>\n<tr>\n<td>Query Complexity</td>\n<td>Supports joins, aggregations, complex queries</td>\n<td>Limited joins; optimized for specific access patterns</td>\n</tr>\n<tr>\n<td>Scalability</td>\n<td>Vertical scaling (scale-up)</td>\n<td>Horizontal scaling (sharding, scale-out)</td>\n</tr>\n<tr>\n<td>Schema Evolution</td>\n<td>Rigid; migrations required</td>\n<td>Flexible; schema-less or dynamic</td>\n</tr>\n<tr>\n<td>Use Cases</td>\n<td>Financial systems, ERP, strong consistency needed</td>\n<td>Real-time analytics, IoT, flexible evolving data</td>\n</tr>\n<tr>\n<td>Maturity/Tooling</td>\n<td>Mature ecosystem (ORMs, tools, drivers)</td>\n<td>Newer, evolving ecosystem</td>\n</tr>\n<tr>\n<td>Cost/Complexity</td>\n<td>Can be costly to scale horizontally</td>\n<td>Operational complexity in sharding &#x26; consistency</td>\n</tr>\n</tbody>\n</table>\n<h3>Monolith vs Microservices</h3>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Monolith</th>\n<th>Microservices</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Architecture</td>\n<td>Single codebase &#x26; deployment</td>\n<td>Multiple independent services</td>\n</tr>\n<tr>\n<td>Development Speed</td>\n<td>Fast to start; simple CI/CD</td>\n<td>Independent teams; faster feature velocity at scale</td>\n</tr>\n<tr>\n<td>Scalability</td>\n<td>Scale entire app together</td>\n<td>Scale services independently</td>\n</tr>\n<tr>\n<td>Operational Complexity</td>\n<td>Simple deployment, debugging, monitoring</td>\n<td>Requires service discovery, API Gateway, observability</td>\n</tr>\n<tr>\n<td>Team Size Fit</td>\n<td>Small teams (startup phase)</td>\n<td>Large teams (clear domain boundaries)</td>\n</tr>\n<tr>\n<td>Data Consistency</td>\n<td>Single DB ‚Üí easy consistency</td>\n<td>Distributed data ‚Üí eventual consistency (Saga)</td>\n</tr>\n<tr>\n<td>Tech Stack Choice</td>\n<td>One tech stack</td>\n<td>Polyglot per service possible</td>\n</tr>\n<tr>\n<td>Failure Isolation</td>\n<td>Failure affects whole system</td>\n<td>Failures isolated per service</td>\n</tr>\n<tr>\n<td>Migration Path</td>\n<td>Can evolve into modular monolith, then microservices</td>\n<td>Start microservices only if domain is complex</td>\n</tr>\n</tbody>\n</table>\n<h3>Vertical vs Horizontal</h3>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Vertical Scaling (Scale Up)</th>\n<th>Horizontal Scaling (Scale Out)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Definition</td>\n<td>Add more resources (CPU, RAM, disk) to a single machine</td>\n<td>Add more machines/nodes to distribute the load</td>\n</tr>\n<tr>\n<td>Complexity</td>\n<td>Simple to implement; minimal code changes</td>\n<td>Requires distributed systems design (load balancing, sharding)</td>\n</tr>\n<tr>\n<td>Hardware Limitations</td>\n<td>Limited by max capacity of a single machine</td>\n<td>Can scale almost infinitely by adding more nodes</td>\n</tr>\n<tr>\n<td>Fault Tolerance</td>\n<td>Single point of failure; if server fails, system down</td>\n<td>High availability; other nodes handle failures</td>\n</tr>\n<tr>\n<td>Cost</td>\n<td>Expensive for high-end hardware (diminishing returns)</td>\n<td>Cheaper commodity hardware; cost grows linearly</td>\n</tr>\n<tr>\n<td>Data Management</td>\n<td>Centralized; no data distribution required</td>\n<td>Requires partitioning, replication, consistency management</td>\n</tr>\n<tr>\n<td>Use Cases</td>\n<td>Small/medium apps, early-stage startups</td>\n<td>Large-scale apps, microservices, cloud-native systems</td>\n</tr>\n<tr>\n<td>Example</td>\n<td>Upgrading server from 8-core to 64-core CPU</td>\n<td>Adding 10 servers behind a load balancer</td>\n</tr>\n</tbody>\n</table>\n"},"relatedPosts":[{"id":"career/principal-engineer","title":"Principal Engineer","date":"2025-07-30"},{"id":"career/resume","title":"Resume","date":"2025-05-01"}]},"__N_SSG":true}